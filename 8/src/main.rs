use grid::Grid;
use itertools::Itertools;
use std::collections::HashSet;
use std::fs::File;
use std::io::{BufRead, BufReader, Lines};
use std::time::{Duration, Instant};

// BOILERPLATE
type InputIter = Lines<BufReader<File>>;

pub fn get_input() -> InputIter {
    let f = File::open("input").unwrap();
    let br = BufReader::new(f);
    br.lines()
}

fn duration_format(duration: Duration) -> String {
    match duration.as_secs_f64() {
        x if x > 1.0 => format!("{:.3}s", x),
        x if x > 0.010 => format!("{:.3}ms", x * 1e3),
        x => format!("{:.3}us", x * 1e6),
    }
}

fn main() {
    let input = get_input();
    let start = Instant::now();
    let ans1 = problem1(input);
    let duration1 = start.elapsed();
    println!("Problem 1 solution: {} [{}]", ans1, duration_format(duration1));

    let input = get_input();
    let start = Instant::now();
    let ans2 = problem2(input);
    let duration2 = start.elapsed();
    println!("Problem 2 solution: {} [{}]", ans2, duration_format(duration2));
    println!("Total duration: {}", duration_format(duration1 + duration2));
}

struct AntennaMap {
    map: Grid<u8>,
}

impl<T: BufRead> From<Lines<T>> for AntennaMap {
    fn from(input: Lines<T>) -> Self {
        Self { map: Grid::from(input) }
    }
}

impl AntennaMap {
    fn find_antinodes(&self, start: usize, reps: Option<usize>) -> Grid<bool> {
        let mut antinodes = Grid::with_shape(self.map.width(), self.map.height(), false);
        // find the unique frequencies in a dumb way
        // NOTE: The dumb way is faster than the slightly-smarter ways I tried
        let freq_set: HashSet<&u8> = HashSet::from_iter(self.map.data.iter().filter(|c| **c != b'.'));

        // for each unique frequency, get all the pairs' positions
        for freq in freq_set {
            for pair in self
                .map
                .data
                .iter()
                .enumerate()
                .filter(|(_, c)| *c == freq)
                .map(|(i, _)| self.map.coord(i as i64).unwrap())
                .permutations(2)
            {
                // permutations generates both pairs, ie. ((1,2),(2,1)) and ((2,1),(1,2)) so we don't need
                // to consider the 'negative' side of the line, which will be generated by the other pair
                let (a, b) = (pair[0], pair[1]);
                let offset = (a.0 - b.0, a.1 - b.1);
                for i in (start..).map_while(|i| {
                    if Some(i - start) != reps {
                        Some(i as i64)
                    } else {
                        None
                    }
                }) {
                    let node_pos = (a.0 + i * offset.0, a.1 + i * offset.1);
                    if !antinodes.set(node_pos.0, node_pos.1, true) {
                        // left the grid
                        break;
                    }
                }
            }
        }
        antinodes
    }
}

// PROBLEM 1 solution

fn problem1<T: BufRead>(input: Lines<T>) -> u64 {
    let map = AntennaMap::from(input);

    let antinodes = map.find_antinodes(1, Some(1));
    antinodes.count(true) as u64
}

// PROBLEM 2 solution
fn problem2<T: BufRead>(input: Lines<T>) -> u64 {
    let map = AntennaMap::from(input);

    let antinodes = map.find_antinodes(0, None);
    antinodes.count(true) as u64
}

#[cfg(test)]
mod tests {
    use crate::*;
    use std::io::Cursor;

    const EXAMPLE: &str = &"............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............";

    #[test]
    fn problem1_example() {
        let c = Cursor::new(EXAMPLE);
        assert_eq!(problem1(c.lines()), 14);
    }

    #[test]
    fn problem2_example() {
        let c = Cursor::new(EXAMPLE);
        assert_eq!(problem2(c.lines()), 34);
    }
}
